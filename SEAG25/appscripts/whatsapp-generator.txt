/**
 * SEAG25 WhatsApp Message Generator
 * ---------------------------------
 * Mirrors the AYG25 workflow but lets us re-map columns by changing
 * `COLUMN_LETTERS` instead of hunting down magic numbers.
 *
 * Sheets required inside 1OR1P9sp0JQz0UyYd8hyn2P3F3B08GUBW:
 *   1. `SEAG25 Competition Schedule` (data, headers at row 8)
 *   2. `WA Template Mapping` sheet with columns:
 *        A: Template Key
 *        B: Sports (newline-delimited list)
 *        C: Disciplines (newline-delimited list)
 *        D: Events (newline-delimited list)
 *        E: Rounds (newline-delimited list)
 *        F: H2H flag
 *        G: Team type descriptor
 *        H: Result type
 *        I: WhatsApp template body
 *        J: JSON list of placeholders (optional)
 *        K: JSON field map (optional)
 *        L: Sample / notes
 *
 * Columns to keep (already present in the schedule):
 *   AP – WhatsApp Message (auto-generated, script writes here)
 *   AQ – Web Results (auto-generated, reserved for future work)
 *   AR – Manual WhatsApp overrides
 *   AS – Manual Web overrides
 *   AT – Recorded By (optional status/IC name)
 *
 * If you need to move/add columns later, just update the letters in
 * `COLUMN_LETTERS`; the rest of the code uses those mappings.
 */

const CONFIG = {
  scheduleSheetName: 'SEAG25 Competition Schedule',
  templateSheetName: 'WA Template Mapping',
  headerRow: 8,
  startRow: 9,
  outputHeaders: {
    whatsapp: 'WHATSAPP MESSAGE (AUTO GENERATED)',
    web: 'WEB RESULTS (AUTO GENERATED)'
  },
  colors: {
    complete: '#d9ead3',
    incomplete: '#f4cccc',
    missing: '#f4cccc',
    neutral: '#ffffff'
  }
};

/**
 * Highlights Generator Configuration
 */
const HIGHLIGHTS_CONFIG = {
  // Firebase Function URL
  FIREBASE_FUNCTION_URL: 'https://us-central1-major-e910d.cloudfunctions.net/generateHighlightsHttpV2',
  
  // Google Sheet ID
  SPREADSHEET_ID: '15zXDQdkGeAN2AMMdrJ_qjkjReq_Y3mlU1-_7ciniyS4',
  
  // Sheet name containing the competition schedule
  SHEET_NAME: 'Com Schedule - Test', // Change to 'SEAG25 Competition Schedule' for production
  
  // Google Drive folder ID where highlights will be saved
  DRIVE_FOLDER_ID: '1K4YiYIPwka_KESNDzFFBmtGuyiF7cdQx',
  
  // Timeout for function execution (in milliseconds)
  TIMEOUT_MS: 300000 // 5 minutes
};

/**
 * Logical headers mapped to the exact text found in row 8.
 * Update this map whenever the sheet header text changes.
 */
const HEADER_LABELS = {
  DATE_THA: 'DATE',
  TIME_START_THA: 'TIME START (THA) 24HR CLOCK',
  TIME_END_THA: 'TIME END (THA) 24HR CLOCK',
  TIME_START_SGP: 'TIME START (SGP) 24HR CLOCK',
  TIME_END_SGP: 'TIME END (SGP) 24HR CLOCK',
  SPORT: 'SPORT',
  DISCIPLINE: 'DISCIPLINE',
  EVENT_GENDER: 'EVENT GENDER',
  EVENT: 'EVENT',
  EVENT_KEY: 'EVENT KEY',
  TEAM_EVENT: 'TEAM SPORT/EVENT',
  ATHLETE_NAME: 'NAME OF ATHLETE (SGP)',
  ROUND: 'STAGE / ROUND OF COMPETITION (TEMPLATE)',
  FIXTURES: 'FIXTURES',
  BROADCAST: 'BROADCAST',
  MEDAL_TALLY_FLAG: 'ADD INTO MEDAL TALLY (NON-DEMO)',
  VENUE: 'COMPETITION VENUE',
  COMPETITOR_NAME: 'NAME OF ATHLETE (COMPETITOR)',
  COMPETITOR_COUNTRY: 'COUNTRY NAME (COMPETITOR)',
  COUNTRY_SGP: 'COUNTRY NAME (SGP)',
  POSITION: 'POSITION',
  MEDAL_RESULT: 'MEDAL',
  SCORE_COMPETITOR: 'SCORE (COMPETITOR)',
  SCORE_SGP: 'SCORE/DISTANCE/HEIGHT (SGP)',
  TIMING_COMPETITOR: 'TIMING (COMPETITORS)',
  TIMING_SGP: 'TIMING (SGP) HH:MM:SS.MS',
  PB_NR: 'PB/NR/GR',
  H2H_RESULT: 'H2H WIN/DRAW/LOSE',
  ROUND_POSITION: 'POSITION IN ENTIRE ROUND',
  ROUND_COMPETITORS: 'NO OF COMPETITORS IN ENTIRE ROUND',
  FINAL_POSITION: 'FINAL POSITION IN EVENT',
  EVENT_COMPETITORS: 'NUMBER OF COMPETITIORS IN EVENT',
  WIN_TYPE: 'WIN TYPE',
  ADVANCEMENT_STATUS: 'ADVANCED',
  MEDAL_TEXT: 'MEDAL',
  REMARKS: 'REMARKS',
  MILESTONES: 'MILESTONES',
  RECORDS: 'RECORDS',
  WHATSAPP_AUTO: 'WHATSAPP MESSAGE (AUTO GENERATED)',
  WEB_AUTO: 'WEB RESULTS (AUTO GENERATED)',
  RECORDED_BY: 'RECORDED BY',
  PB_NR_KEY: 'PB-NR KEY',
  EVENT_GENDER_INTERNAL: 'EVENT GENDER (INTERNAL)',
  EVENT_INTERNAL: 'EVENT (INTERNAL)',
  REPORTED_STATUS: 'REPORTED (FOLLOW SGP DATE AND TIME)',
  RESULT_TYPE: 'RESULTS TYPE',
  TOTAL_SCORE: 'TOTAL SCORE (SGP)',
  NEXT_OPPONENT: 'NEXT OPPONENT',
  NEXT_DAY: 'NEXT DAY',
  NEXT_TIME: 'NEXT TIME (THA)',
  NEXT_ROUND: 'NEXT ROUND',
  HEAT: 'HEAT NUMBER',
  TOTAL_PLACEMENT: 'FINAL POSITION IN EVENT',
  TOTAL_TOTAL: 'NUMBER OF COMPETITIORS IN EVENT' 
};

let HEADER_MAP = null;
let COLS = null;
let WHATSAPP_COL = null;
let WEB_COL = null;
let LAST_DATA_COLUMN = null;
let SCHEDULE_DATA_ROWS = null;
let CURRENT_ROW_INDEX = null;
let NEXT_MATCH_CACHE = null;

function setScheduleDataRows(rows) {
  SCHEDULE_DATA_ROWS = rows;
}

function setCurrentRowIndex(index) {
  CURRENT_ROW_INDEX = index;
  NEXT_MATCH_CACHE = null;
}

function normalizeHeaderName(name) {
  return name ? name.toString().replace(/\s+/g, ' ').trim().toUpperCase() : '';
}

function ensureColumnIndexes() {
  if (COLS && WHATSAPP_COL !== null && LAST_DATA_COLUMN !== null) {
    return;
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(CONFIG.scheduleSheetName);
  if (!sheet) {
    throw new Error(`Schedule sheet not found: ${CONFIG.scheduleSheetName}`);
  }

  const lastColumn = sheet.getLastColumn();
  const headerValues = sheet
    .getRange(CONFIG.headerRow, 1, 1, lastColumn)
    .getValues()[0];

  HEADER_MAP = {};
  headerValues.forEach((value, idx) => {
    const normalized = normalizeHeaderName(value);
    if (normalized) {
      HEADER_MAP[normalized] = idx;
    }
  });

  COLS = {};
  Object.entries(HEADER_LABELS).forEach(([key, headerText]) => {
    const normalized = normalizeHeaderName(headerText);
    if (HEADER_MAP.hasOwnProperty(normalized)) {
      COLS[key] = HEADER_MAP[normalized];
    }
  });

  WHATSAPP_COL = (COLS.WHATSAPP_AUTO ?? 0) + 1;
  WEB_COL = (COLS.WEB_AUTO ?? 0) + 1;
  LAST_DATA_COLUMN = lastColumn;
}

/**
 * Placeholders supported inside Whatsapp Mapping templates.
 * Add/remove mappings here whenever we introduce new placeholders.
 */
const OPTIONAL_PLACEHOLDERS = new Set(['{PB_NR_TEXT}', '{PB/NR/GR}']);

const PLACEHOLDER_TO_FIELD = {
  '{SPORT}': 'SPORT',
  '{DISCIPLINE}': 'DISCIPLINE',
  '{GENDER}': 'EVENT_GENDER',
  '{EVENT}': 'EVENT',
  '{EVENT_NAME}': 'EVENT',
  '{ROUND}': 'ROUND',
  '{ROUNDS}': 'ROUND',
  '{TEAM_EVENT}': 'TEAM_EVENT',
  '{VENUE}': 'VENUE',
  '{COUNTRY}': 'COUNTRY_SGP',
  '{COUNTRY2}': 'COMPETITOR_COUNTRY',
  '{COMPETITOR}': 'COMPETITOR_NAME',
  '{ATHLETE}': 'ATHLETE_NAME',
  '{ATHLETE_UC}': 'ATHLETE_NAME',
  '{ATHLETE1}': 'ATHLETE_NAME',
  '{PLAYER1}': 'ATHLETE_NAME',
  '{NAME}': 'ATHLETE_NAME',
  '{NAMES}': 'ATHLETE_NAME',
  '{ATHLETE2}': 'COMPETITOR_NAME',
  '{PLAYER2}': 'COMPETITOR_NAME',
  '{SCORE}': 'SCORE_SGP',
  '{SCORE1}': 'SCORE_SGP',
  '{SCORE2}': 'SCORE_COMPETITOR',
  '{DISTANCE}': 'SCORE_SGP',
  '{HEIGHT}': 'SCORE_SGP',
  '{TIMING}': 'TIMING_SGP',
  '{TIMING_COMP}': 'TIMING_COMPETITOR',
  '{TIME}': 'TIMING_SGP',
  '{POSITION}': 'POSITION',
  '{ROUND_POSITION}': 'ROUND_POSITION',
  '{ROUND_TOTAL}': 'ROUND_COMPETITORS',
  '{TOTAL}': 'ROUND_COMPETITORS',
  '{PLACEMENT}': 'ROUND_POSITION',
  '{FINAL_POSITION}': 'FINAL_POSITION',
  '{EVENT_TOTAL}': 'EVENT_COMPETITORS',
  '{MEDAL}': 'MEDAL_RESULT',
  '{MEDAL_TEXT}': 'MEDAL_TEXT',
  '{ADVANCEMENT_STATUS}': 'ADVANCEMENT_STATUS',
  '{MEDAL_STATUS}': 'MEDAL_TEXT',
  '{WIN_TYPE}': 'WIN_TYPE',
  '{REMARKS}': 'REMARKS',
  '{MILESTONES}': 'MILESTONES',
  '{RECORDS}': 'RECORDS',
  '{PB_NR_TEXT}': 'PB_NR',
  '{PB/NR/GR}': 'PB_NR',
  '{DATE_THA}': 'DATE_THA',
  '{DATE_SGP}': 'DATE_THA',
  '{TIME_THA}': 'TIME_START_THA',
  '{TIME_SGP}': 'TIME_START_SGP',
  '{TOTAL_SCORE}': 'TOTAL_SCORE',
  '{NEXT_OPPONENT}': 'NEXT_OPPONENT',
  '{NEXT_DAY}': 'NEXT_DAY',
  '{NEXT_TIME}': 'NEXT_TIME',
  '{NEXT_ROUND}': 'NEXT_ROUND',
  '{HEAT}': 'HEAT',
  '{TOTAL_PLACEMENT}': 'TOTAL_PLACEMENT',
  '{TOTAL_TOTAL}': 'TOTAL_TOTAL',
  '{H2H_RESULT}': 'H2H_RESULT',
  '{WINNER}': null,
  '{LOSER}': null,
  '{WIN_SCORE}': null,
  '{LOSE_SCORE}': null
};

/**
 * Menu on open
 */
function onOpen() {
  ensureColumnIndexes();
  SpreadsheetApp.getUi()
    .createMenu('SEAG Tools')
    .addItem('Generate WhatsApp & Web Results', 'generateWhatsAppForSelection')
    .addSeparator()
    .addItem('Verify template coverage', 'verifyTemplateCoverage')
    .addSeparator()
    .addItem('Sync Results to SEA Sheet', 'syncSeaResults')
    .addSeparator()
    .addItem('Generate Highlights (Today)', 'generateHighlightsToday')
    .addItem('Generate Highlights (Select Date)', 'generateHighlightsForDate')
    .addSeparator()
    .addItem('Test Highlights Connection', 'testHighlightsConnection')
    .addToUi();
}

/**
 * Generate WhatsApp messages for selected rows.
 */
function generateWhatsAppForSelection() {
  ensureColumnIndexes();
  const sheet = SpreadsheetApp.getActiveSheet();
  if (sheet.getName() !== CONFIG.scheduleSheetName) {
    SpreadsheetApp.getUi().alert(`Please run this on "${CONFIG.scheduleSheetName}".`);
    return;
  }

  const selection = sheet.getActiveRange();
  const templates = getTemplateMapping();

  const lastRow = sheet.getLastRow();
  if (lastRow < CONFIG.startRow) {
    SpreadsheetApp.getUi().alert('No data rows found.');
    return;
  }

  const allData = sheet
    .getRange(CONFIG.startRow, 1, lastRow - CONFIG.startRow + 1, LAST_DATA_COLUMN)
    .getValues();
  setScheduleDataRows(allData);

  for (let i = 0; i < selection.getNumRows(); i++) {
    const rowNumber = selection.getRow() + i;
    if (rowNumber < CONFIG.startRow) {
      continue; // skip header rows
    }

    const dataIndex = rowNumber - CONFIG.startRow;
    const row = allData[dataIndex];
    setCurrentRowIndex(dataIndex);
    const templateEntry = findTemplateForRow(templates, row);
    const whatsappCell = sheet.getRange(rowNumber, WHATSAPP_COL);

    if (!templateEntry) {
      whatsappCell
        .setBackground(CONFIG.colors.incomplete)
        .setValue('No template mapping found');
      continue;
    }

    const templateText = templateEntry.template;
    const missingFields = checkMissingFields(row, templateText);
    clearMissingHighlights(sheet, rowNumber, templateText, row);

    if (missingFields.length) {
      highlightMissingFields(sheet, rowNumber, missingFields);
      whatsappCell
        .setBackground(CONFIG.colors.missing)
        .setValue('Missing required data');
      continue;
    }

    const message = replacePlaceholders(templateText, row);
    const finalMessage = sanitizeFinalOutput(message);
    const webSummary = extractWebResultsSection(finalMessage);
    whatsappCell.setValue(finalMessage || '');
    if (WEB_COL) {
      const webCell = sheet.getRange(rowNumber, WEB_COL);
      webCell.setValue(webSummary || '');
    }

    if (isMessageComplete(finalMessage)) {
      whatsappCell.setBackground(CONFIG.colors.complete);
    } else {
      whatsappCell.setBackground(CONFIG.colors.incomplete);
    }
  }
}

/**
 * Ensure we have templates for each SPORT/EVENT/ROUND in the schedule.
 */
function verifyTemplateCoverage() {
  ensureColumnIndexes();
  const sheet = SpreadsheetApp.getActive()
    .getSheetByName(CONFIG.scheduleSheetName);
  const lastRow = sheet.getLastRow();
  const data = sheet
    .getRange(CONFIG.startRow, 1, lastRow - CONFIG.startRow + 1, LAST_DATA_COLUMN)
    .getValues();
  const templates = getTemplateMapping();
  const missing = [];

  data.forEach(row => {
    const sport = safeUpper(row[COLS.SPORT]);
    const discipline = safeUpper(row[COLS.DISCIPLINE]);
    const event = safeUpper(row[COLS.EVENT]);
    const round = safeUpper(row[COLS.ROUND]);
    if (!sport || !event || !round) {
      return;
    }
    const templateEntry = findTemplateForRow(templates, row);
    if (!templateEntry) {
      missing.push(`${sport} | ${discipline} | ${event} | ${round}`);
    }
  });

  SpreadsheetApp.getUi().alert(
    missing.length
      ? `Missing templates for ${missing.length} row(s).\nExample: ${missing[0]}`
      : 'All schedule rows have a matching template.'
  );
}

/**
 * Build template key SPORT|EVENT|ROUND (all uppercase for safety)
 */
function getTemplateMapping() {
  const sheet = SpreadsheetApp.getActive()
    .getSheetByName(CONFIG.templateSheetName);
  if (!sheet) {
    throw new Error(`Template sheet "${CONFIG.templateSheetName}" not found.`);
  }

  const values = sheet.getDataRange().getValues();
  const templates = [];

  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const templateText = row[8];
    if (!templateText) {
      continue;
    }

    templates.push({
      key: row[0] || `ROW_${i + 1}`,
      sports: parseListCell(row[1]),
      disciplines: parseListCell(row[2]),
      events: parseListCell(row[3]),
      rounds: parseListCell(row[4]),
      h2h: (row[5] || '').toString().trim().toLowerCase(),
      teamType: (row[6] || '').toString().trim().toLowerCase(),
      resultType: (row[7] || '').toString().trim().toLowerCase(),
      template: templateText,
      placeholders: parseJsonList(row[9]),
      fieldMap: parseJsonMap(row[10]),
      sample: row[11] || ''
    });
  }

  return templates;
}

function parseListCell(value) {
  if (!value || value === '—') {
    return [];
  }
  return value
    .toString()
    .split(/\n|,/)
    .map(item => safeUpper(item))
    .filter(Boolean);
}

function parseJsonList(value) {
  if (!value) return [];
  try {
    const parsed = JSON.parse(value);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    Logger.log(`Unable to parse placeholder list: ${error}`);
    return [];
  }
}

function parseJsonMap(value) {
  if (!value) return {};
  try {
    const parsed = JSON.parse(value);
    return typeof parsed === 'object' && parsed !== null ? parsed : {};
  } catch (error) {
    Logger.log(`Unable to parse field map: ${error}`);
    return {};
  }
}

function findTemplateForRow(templates, row) {
  ensureColumnIndexes();
  const sport = safeUpper(row[COLS.SPORT]);
  const discipline = safeUpper(row[COLS.DISCIPLINE]);
  const event = safeUpper(row[COLS.EVENT]);
  const round = safeUpper(row[COLS.ROUND]);

  const matches = [];
  for (const template of templates) {
    if (matchesTemplateRule(template, row, sport, discipline, event, round)) {
      matches.push(template);
    }
  }

  if (!matches.length) {
    return null;
  }

  const totalScoreValue = COLS.TOTAL_SCORE !== undefined ? row[COLS.TOTAL_SCORE] : null;
  const hasTotalScore = hasValue(totalScoreValue);

  const templateWithTotal = matches.find(t => templateRequiresPlaceholder(t, '{TOTAL_SCORE}'));
  const templateWithoutTotal = matches.find(t => !templateRequiresPlaceholder(t, '{TOTAL_SCORE}'));

  if (hasTotalScore && templateWithTotal) {
    return templateWithTotal;
  }
  if (!hasTotalScore && templateWithoutTotal) {
    return templateWithoutTotal;
  }

  return matches[0];
}

function templateRequiresPlaceholder(template, placeholder) {
  if (template.placeholders && template.placeholders.length) {
    return template.placeholders.includes(placeholder);
  }
  return template.template && template.template.indexOf(placeholder) !== -1;
}

function matchesTemplateRule(rule, row, sport, discipline, event, round) {
  const sportMatch = !rule.sports.length || rule.sports.includes(sport);
  const disciplineMatch = !rule.disciplines.length || rule.disciplines.includes(discipline);
  const eventMatch = !rule.events.length || rule.events.includes(event);
  const roundMatch = !rule.rounds.length || rule.rounds.includes(round);

  const teamFlag = (row[COLS.TEAM_EVENT] || '').toString().trim();
  const isTeamRow = teamFlag === '1';
  const normalizedTeamType = (rule.teamType || '').replace(/\s+/g, '').toLowerCase();
  const teamMatch =
    !normalizedTeamType ||
    normalizedTeamType === 'all' ||
    normalizedTeamType === 'indiv/team' ||
    normalizedTeamType === 'team/indiv' ||
    (normalizedTeamType === 'team' && isTeamRow) ||
    (normalizedTeamType === 'indiv' && !isTeamRow);

  const h2hColumn = safeUpper(row[COLS.H2H_RESULT] || '');
  const ruleH2H = (rule.h2h || '').toLowerCase();
  const h2hMatch =
    !ruleH2H ||
    (ruleH2H === 'yes' && !!h2hColumn) ||
    (ruleH2H === 'no');

  return sportMatch && disciplineMatch && eventMatch && roundMatch && teamMatch && h2hMatch;
}

/**
 * Highlight cells that are missing data for the required placeholders.
 */
function highlightMissingFields(sheet, rowNumber, missingFields) {
  missingFields.forEach(field => {
    sheet.getRange(rowNumber, field + 1).setBackground(CONFIG.colors.missing);
  });
}

/**
 * Clear previous red backgrounds only for cells that now contain data.
 */
function clearMissingHighlights(sheet, rowNumber, template, row) {
  ensureColumnIndexes();
  const placeholders = extractPlaceholders(template);
  const columns = new Set(
    placeholders
      .map(ph => {
        const fieldKey = PLACEHOLDER_TO_FIELD[ph];
        return fieldKey ? COLS[fieldKey] : null;
      })
      .filter(idx => idx !== undefined && idx !== null)
  );
  columns.forEach(idx => {
    const cell = sheet.getRange(rowNumber, idx + 1);
    const background = cell.getBackground();
    if ((background === CONFIG.colors.missing || background === '#f4cccc') &&
        hasValue(row[idx])) {
      cell.setBackground(CONFIG.colors.neutral);
    }
  });
}

function checkMissingFields(row, template) {
  ensureColumnIndexes();
  const missing = [];
  const placeholders = extractPlaceholders(template);
  placeholders.forEach(ph => {
    if (OPTIONAL_PLACEHOLDERS.has(ph)) {
      return;
    }
    const fieldKey = PLACEHOLDER_TO_FIELD[ph];
    if (!fieldKey) {
      return;
    }
    const colIdx = COLS[fieldKey];
    if (colIdx === undefined || colIdx === null) {
      return;
    }
    if (!hasValue(row[colIdx])) {
      missing.push(colIdx);
    }
  });
  return missing;
}

function replacePlaceholders(template, row) {
  ensureColumnIndexes();
  let message = template;

  Object.entries(PLACEHOLDER_TO_FIELD).forEach(([ph, fieldKey]) => {
    const colIdx = fieldKey ? COLS[fieldKey] : undefined;
    const baseValue = colIdx !== undefined ? row[colIdx] : undefined;
    const value = formatValueForPlaceholder(ph, baseValue, row);
    const safeValue = value === undefined || value === null ? '' : value;
    message = message.split(ph).join(safeValue);
  });

  // Clean double spaces and stray punctuation.
  return message
    .replace(/ {2,}/g, ' ')
    .replace(/\t+/g, ' ')
    .replace(/\.{1}\s+\./g, '.')
    .replace(/\. \n/g, '.\n')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

function formatValueForPlaceholder(placeholder, rawValue, row) {
  ensureColumnIndexes();
  const h2h = getHeadToHeadDetails(row);
  const finalRound = isFinalRound(row);
  switch (placeholder) {
    case '{ATHLETE}':
    case '{ATHLETE1}':
    case '{PLAYER1}':
    case '{NAME}':
    case '{NAMES}':
      return row[COLS.ATHLETE_NAME] || '';
    case '{ATHLETE2}':
    case '{PLAYER2}':
      return row[COLS.COMPETITOR_NAME] || '';
    case '{ATHLETE_UC}':
      return safeUpper(row[COLS.ATHLETE_NAME]);
    case '{COUNTRY}':
      return row[COLS.COUNTRY_SGP] || 'SGP';
    case '{COUNTRY2}':
      return row[COLS.COMPETITOR_COUNTRY] || '';
    case '{DATE_THA}':
      return formatDate(row[COLS.DATE_THA]);
    case '{DATE_SGP}':
      return formatDate(row[COLS.DATE_THA]); // Single source for now
    case '{TIME_THA}':
      return formatTime(row[COLS.TIME_START_THA]);
    case '{TIME_SGP}':
      return formatTime(row[COLS.TIME_START_SGP]);
    case '{TIME}':
    case '{TIMING}':
      return formatPerformanceTiming(row[COLS.TIMING_SGP]);
    case '{TIMING_COMP}':
      return formatPerformanceTiming(row[COLS.TIMING_COMPETITOR]);
    case '{POSITION}':
    case '{PLACEMENT}':
    case '{ROUND_POSITION}':
    case '{FINAL_POSITION}':
      return addOrdinalSuffix(rawValue);
    case '{ROUND_TOTAL}':
    case '{TOTAL}':
      return row[COLS.ROUND_COMPETITORS] || '';
    case '{EVENT_TOTAL}':
      return row[COLS.EVENT_COMPETITORS] || '';
    case '{SCORE}':
    case '{SCORE1}':
      return formatScore(row[COLS.SCORE_SGP]);
    case '{SCORE2}':
      return formatScore(row[COLS.SCORE_COMPETITOR]);
    case '{DISTANCE}':
    case '{HEIGHT}':
      return formatScore(row[COLS.SCORE_SGP]);
    case '{TOTAL_SCORE}':
      return row[COLS.TOTAL_SCORE] || '';
    case '{ADVANCEMENT_STATUS}':
      return getAdvancementStatusMessage(row);
    case '{MEDAL_STATUS}':
      return finalRound ? getMedalStatusText(row) : '';
    case '{PB_NR_TEXT}':
      return getPBNRText(row);
    case '{NEXT_OPPONENT}':
      return getNextOpponentValue(row);
    case '{NEXT_DAY}':
      return getNextDayValue(row);
    case '{NEXT_TIME}':
      return getNextTimeValue(row);
    case '{NEXT_ROUND}':
      return getNextRoundValue(row);
    case '{HEAT}':
      return formatHeatValue(row[COLS.HEAT]);
    case '{TOTAL_PLACEMENT}':
      return addOrdinalSuffix(row[COLS.TOTAL_PLACEMENT]);
    case '{TOTAL_TOTAL}':
      return row[COLS.TOTAL_TOTAL] || '';
    case '{WINNER}':
      return h2h.winner;
    case '{LOSER}':
      return h2h.loser;
    case '{WIN_SCORE}':
      return h2h.winScore;
    case '{LOSE_SCORE}':
      return h2h.loseScore;
    default:
      return rawValue || '';
  }
}

function extractPlaceholders(template) {
  const matches = template.match(/{[A-Z0-9_]+}/g);
  return matches ? Array.from(new Set(matches)) : [];
}

function isMessageComplete(message) {
  if (!message) return false;
  if (message.includes('{') && message.includes('}')) return false;
  if (/undefined|null/.test(message)) return false;
  return true;
}

function sanitizeFinalOutput(text) {
  if (!text) return text;
  let collapsed = text.replace(/\.{2,}/g, '.');
  collapsed = collapsed.replace(/\s*\n+\s*(SGP (?:won|will|advanced|received)[^\n]*)/gi, ' $1');
  collapsed = collapsed.replace(/\s*\n+\s*(Did not advance\.)/gi, ' $1');
  collapsed = collapsed.replace(/\s*\n+\s*(This is a new [^\n]+)/gi, ' $1');
  return ensureSentencePeriods(collapsed);
}

function ensureSentencePeriods(text) {
  const lines = text.split('\n');
  const updated = lines.map(line => {
    const trimmed = line.trim();
    if (!trimmed) return line;
    if (/^\*/.test(trimmed)) {
      return line;
    }
    if (/[.!?)]$/.test(trimmed)) {
      return line;
    }
    return line + '.';
  });
  return updated.join('\n');
}

function extractWebResultsSection(message) {
  if (!message) return '';
  const segments = message
    .split(/\n{2,}/)
    .map(part => part.trim())
    .filter(Boolean);
  if (!segments.length) return '';

  const narrativeSegments = segments.filter(seg => !/^\*/.test(seg));
  const body = narrativeSegments.length ? narrativeSegments : [segments[segments.length - 1]];
  const summary = body.join('\n\n');
  return stripScheduleDetails(summary);
}

function stripScheduleDetails(text) {
  if (!text) return '';
  let cleaned = text.replace(/\s+on\s+[^\.\n]+?\(THA\)\.?/gi, '');
  cleaned = cleaned.replace(/\s+on\s+[^\.\n]+$/gi, '');
  const paragraphs = cleaned
    .split(/\n{2,}/)
    .map(chunk => chunk.trim())
    .filter(Boolean);
  const summaryParts = paragraphs.length <= 2
    ? paragraphs
    : paragraphs.slice(paragraphs.length - 2);
  const joined = summaryParts.join(' ');
  const withoutNames = joined.replace(/^[A-Z \.\(\)]+?\(SGP\)\s*/i, '');
  return sanitizeFinalOutput(withoutNames).replace(/\s+/g, ' ').trim();
}

function getPBNRText(row) {
  ensureColumnIndexes();
  const raw = (row[COLS.PB_NR] || '').toString().toUpperCase().trim();
  if (!raw || raw === 'NONE') return '';

  const records = raw.split(',').map(r => r.trim()).filter(Boolean);
  const statements = [];
  if (records.includes('PB')) {
    statements.push('This is a new Personal Best.');
  }
  if (records.includes('NR')) {
    statements.push('This is a new National Record.');
  }
  if (records.includes('U17 NR') || records.includes('U17NR')) {
    statements.push('This is a new U17 National Record.');
  }
  if (records.includes('GR')) {
    statements.push('This is a new Games Record.');
  }

  if (!statements.length) return '';
  return ` ${statements.join(' ')}`;
}

function formatDate(value) {
  if (!value) return '';
  if (value instanceof Date) {
    const day = value.getDate().toString().padStart(2, '0');
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return `${day} ${monthNames[value.getMonth()]}`;
  }
  return value;
}

function formatTime(value) {
  if (!value) return '';
  if (value instanceof Date) {
    return Utilities.formatDate(value, Session.getScriptTimeZone(), 'HH:mm') + 'hr';
  }
  // String HH:MM:SS
  const str = value.toString();
  if (/^\d{2}:\d{2}/.test(str)) {
    return str.substring(0, 5) + 'hr';
  }
  return str;
}

function formatPlainTime(value) {
  if (!value) return '';
  if (value instanceof Date) {
    return Utilities.formatDate(value, Session.getScriptTimeZone(), 'HH:mm');
  }
  const str = value.toString().trim();
  if (!str) {
    return '';
  }
  if (/^\d{1,2}:\d{2}/.test(str)) {
    return str.substring(0, 5);
  }
  return str;
}

function formatScore(value) {
  if (value === undefined || value === null) return '';
  return value.toString().trim();
}

/**
 * Format timing string - removes leading zeros and colons
 * Examples: 01:00.10 → 1:00.10, 00:01:10.28 → 1:10.28
 */
function formatPerformanceTiming(value) {
  if (!value) return '';
  
  let result = '';
  if (value instanceof Date) {
    const hours = Utilities.formatDate(value, Session.getScriptTimeZone(), 'H');
    const minutes = Utilities.formatDate(value, Session.getScriptTimeZone(), 'm');
    const seconds = Utilities.formatDate(value, Session.getScriptTimeZone(), 's.SS');
    result = `${hours}:${minutes}:${seconds}`;
  } else {
    result = value.toString().trim();
  }
  
  // Remove leading zeros and colons
  // Pattern: hh:mm:ss.ms or mm:ss.ms or ss.ms
  const parts = result.split(':');
  
  if (parts.length === 3) {
    // Format: hh:mm:ss.ms
    const hours = parseInt(parts[0], 10) || 0;
    const minutes = parseInt(parts[1], 10) || 0;
    const seconds = parts[2];
    
    if (hours === 0 && minutes === 0) {
      // 00:00:ss.ms → ss.ms
      return seconds;
    } else if (hours === 0) {
      // 00:mm:ss.ms → mm:ss.ms (remove leading 0 from minutes if present)
      const minStr = minutes.toString();
      return `${minStr}:${seconds}`;
    } else {
      // hh:mm:ss.ms (remove leading 0 from hours if present)
      const hourStr = hours.toString();
      const minStr = minutes.toString();
      return `${hourStr}:${minStr}:${seconds}`;
    }
  } else if (parts.length === 2) {
    // Format: mm:ss.ms
    const minutes = parseInt(parts[0], 10) || 0;
    const seconds = parts[1];
    
    if (minutes === 0) {
      // 00:ss.ms → ss.ms
      return seconds;
    } else {
      // mm:ss.ms (remove leading 0 from minutes if present)
      const minStr = minutes.toString();
      return `${minStr}:${seconds}`;
    }
  } else {
    // Format: ss.ms (already in correct format, just return)
    return result;
  }
  return str;
}

function formatHeatValue(value) {
  if (!value && value !== 0) return '';
  const text = value.toString().trim();
  if (!text) return '';
  if (/^heat\s+/i.test(text)) {
    return text.toUpperCase();
  }
  return `HEAT ${text}`.toUpperCase();
}

function addOrdinalSuffix(value) {
  const n = parseInt(value, 10);
  if (isNaN(n)) return value || '';
  if (n % 100 >= 11 && n % 100 <= 13) return `${n}th`;
  switch (n % 10) {
    case 1: return `${n}st`;
    case 2: return `${n}nd`;
    case 3: return `${n}rd`;
    default: return `${n}th`;
  }
}

function hasValue(val) {
  return val !== undefined && val !== null && val.toString().trim() !== '';
}

function safeUpper(val) {
  return val ? val.toString().trim().toUpperCase() : '';
}

function getHeadToHeadDetails(row) {
  ensureColumnIndexes();
  const result = { winner: '', loser: '', winScore: '', loseScore: '' };
  const outcome = safeUpper(row[COLS.H2H_RESULT]);
  const sgpCountry = row[COLS.COUNTRY_SGP] || 'SGP';
  const oppCountry = row[COLS.COMPETITOR_COUNTRY] || '';
  const sgpScore = formatScore(row[COLS.SCORE_SGP]);
  const oppScore = formatScore(row[COLS.SCORE_COMPETITOR]);

  if (outcome === 'WIN') {
    result.winner = sgpCountry;
    result.loser = oppCountry;
    result.winScore = sgpScore;
    result.loseScore = oppScore;
  } else if (outcome === 'LOSE') {
    result.winner = oppCountry;
    result.loser = sgpCountry;
    result.winScore = oppScore;
    result.loseScore = sgpScore;
  } else if (outcome === 'DRAW') {
    result.winner = 'DRAW';
    result.loser = 'DRAW';
    result.winScore = sgpScore;
    result.loseScore = oppScore;
  }

  return result;
}

function getMedalStatusText(row) {
  ensureColumnIndexes();
  const rawMedal = (row[COLS.MEDAL_TEXT] || row[COLS.MEDAL_RESULT] || '').toString().trim();
  if (!rawMedal) return '';

  const medal = rawMedal.toLowerCase();
  if (medal.includes('joint gold')) return 'SGP won the joint Gold medal';
  if (medal.includes('joint silver')) return 'SGP won the joint Silver medal';
  if (medal.includes('joint bronze')) return 'SGP won the joint Bronze medal';
  if (medal.includes('gold')) return 'SGP won the Gold medal';
  if (medal.includes('silver')) return 'SGP won the Silver medal';
  if (medal.includes('bronze')) return 'SGP won the Bronze medal';
  return ``;
}

function getAdvancementStatusMessage(row) {
  ensureColumnIndexes();
  const statusValue = getAdvancedStatusValue(row);
  if (!statusValue || statusValue === 'NA') return '';
  if (statusValue === 'NO') {
    return 'Did not advance.';
  }

  const derived = getDerivedNextMatchDetails(row);
  const hasDerivedDetails =
    derived &&
    hasValue(derived.opponent) &&
    hasValue(derived.formattedDate) &&
    hasValue(derived.formattedTime);
  const fallbackRound = getNextRoundValue(row) || 'next round';

  if (hasDerivedDetails) {
    const opponent = derived.opponent;
    const dayText = derived.formattedDate;
    const timeText = `${derived.formattedTime} hrs (THA)`;
    const roundText = derived.round || fallbackRound;
    switch (statusValue) {
      case 'NEXT MATCH':
        return `SGP will next play against ${opponent} on ${dayText} at ${timeText}.`;
      case 'BYE':
        return `SGP received a BYE and advanced to the ${roundText} against ${opponent} on ${dayText} at ${timeText}.`;
      case 'YES':
      default:
        return `SGP advanced to the ${roundText} against ${opponent} on ${dayText} at ${timeText}.`;
    }
  }

  const fallbackDateRaw = formatNextDay(row);
  const fallbackTimeRaw = formatNextTime(row);
  const fallbackDate = fallbackDateRaw || 'TBC';
  const fallbackTime = fallbackTimeRaw ? `${fallbackTimeRaw} hrs (THA)` : 'TBC hrs (THA)';

  if (statusValue === 'NEXT MATCH') {
    return `SGP will next play in the ${fallbackRound} on ${fallbackDate} at ${fallbackTime}.`;
  }

  if (hasValue(fallbackRound) && (hasValue(fallbackDateRaw) || hasValue(fallbackTimeRaw))) {
    return `SGP advanced to the ${fallbackRound} on ${fallbackDate} at ${fallbackTime}.`;
  }

  if (hasValue(fallbackRound)) {
    return `SGP advanced to the ${fallbackRound}.`;
  }

  return 'SGP advanced to the next round.';
}

function getAdvancedStatusValue(row) {
  if (COLS.ADVANCEMENT_STATUS === undefined) {
    return '';
  }
  const raw = row[COLS.ADVANCEMENT_STATUS];
  return raw ? raw.toString().trim().toUpperCase() : '';
}

function getColumnValue(row, columnIndex) {
  if (columnIndex === undefined) return '';
  const value = row[columnIndex];
  return value === undefined || value === null ? '' : value;
}

function formatNextOpponent(row) {
  const value = getColumnValue(row, COLS.NEXT_OPPONENT);
  return value ? value.toString().trim() : '';
}

function formatNextDay(row) {
  const value = getColumnValue(row, COLS.NEXT_DAY);
  if (!value) return '';
  if (value instanceof Date) {
    return formatDate(value);
  }
  return value.toString().trim();
}

function formatNextTime(row) {
  return formatPlainTime(getColumnValue(row, COLS.NEXT_TIME));
}

function formatNextRound(row) {
  const value = getColumnValue(row, COLS.NEXT_ROUND);
  return value ? value.toString().trim() : '';
}

function getDerivedNextMatchDetails(row) {
  if (NEXT_MATCH_CACHE !== null) {
    return NEXT_MATCH_CACHE;
  }
  if (!SCHEDULE_DATA_ROWS || CURRENT_ROW_INDEX === null || CURRENT_ROW_INDEX < 0) {
    NEXT_MATCH_CACHE = null;
    return NEXT_MATCH_CACHE;
  }
  NEXT_MATCH_CACHE = deriveNextMatchFromSchedule(row);
  return NEXT_MATCH_CACHE;
}

function deriveNextMatchFromSchedule(row) {
  ensureColumnIndexes();
  if (!SCHEDULE_DATA_ROWS || CURRENT_ROW_INDEX === null) {
    return null;
  }

  const sport = safeUpper(row[COLS.SPORT]);
  const discipline = safeUpper(row[COLS.DISCIPLINE]);
  const event = safeUpper(row[COLS.EVENT]);
  const athlete = safeUpper(row[COLS.ATHLETE_NAME]);

  for (let i = CURRENT_ROW_INDEX + 1; i < SCHEDULE_DATA_ROWS.length; i++) {
    const candidate = SCHEDULE_DATA_ROWS[i];
    if (sport && safeUpper(candidate[COLS.SPORT]) !== sport) continue;
    if (discipline && safeUpper(candidate[COLS.DISCIPLINE]) !== discipline) continue;
    if (event && safeUpper(candidate[COLS.EVENT]) !== event) continue;

    const candidateAthlete = safeUpper(candidate[COLS.ATHLETE_NAME]);
    if (athlete && candidateAthlete && candidateAthlete !== athlete) continue;

    const opponent = pickOpponentFromRow(candidate);
    const dateRaw = getColumnValue(candidate, COLS.DATE_THA) || getColumnValue(candidate, COLS.NEXT_DAY);
    const timeRaw = getColumnValue(candidate, COLS.TIME_START_THA) || getColumnValue(candidate, COLS.NEXT_TIME);
    const roundRaw = getColumnValue(candidate, COLS.ROUND) || getColumnValue(candidate, COLS.NEXT_ROUND);
    const formattedDate = formatDate(dateRaw);
    const formattedTime = formatPlainTime(timeRaw);

    if (hasValue(opponent) || hasValue(formattedDate) || hasValue(formattedTime)) {
      return {
        opponent: opponent || '',
        formattedDate,
        formattedTime,
        round: roundRaw ? roundRaw.toString().trim() : ''
      };
    }
  }

  return null;
}

function pickOpponentFromRow(row) {
  const derivedOpponent = getColumnValue(row, COLS.NEXT_OPPONENT);
  if (hasValue(derivedOpponent)) {
    return derivedOpponent.toString().trim();
  }
  if (COLS.COMPETITOR_COUNTRY !== undefined) {
    const competitorCountry = row[COLS.COMPETITOR_COUNTRY];
    if (hasValue(competitorCountry)) {
      return competitorCountry.toString().trim();
    }
  }
  if (COLS.COMPETITOR_NAME !== undefined) {
    const competitorName = row[COLS.COMPETITOR_NAME];
    if (hasValue(competitorName)) {
      return competitorName.toString().trim();
    }
  }
  return '';
}

function getNextOpponentValue(row) {
  const derived = getDerivedNextMatchDetails(row);
  if (derived && hasValue(derived.opponent)) {
    return derived.opponent;
  }
  return formatNextOpponent(row);
}

function getNextDayValue(row) {
  const derived = getDerivedNextMatchDetails(row);
  if (derived && hasValue(derived.formattedDate)) {
    return derived.formattedDate;
  }
  return formatNextDay(row);
}

function getNextTimeValue(row) {
  const derived = getDerivedNextMatchDetails(row);
  if (derived && hasValue(derived.formattedTime)) {
    return derived.formattedTime;
  }
  return formatNextTime(row);
}

function getNextRoundValue(row) {
  const derived = getDerivedNextMatchDetails(row);
  if (derived && hasValue(derived.round)) {
    return derived.round;
  }
  return formatNextRound(row);
}

function isFinalRound(row) {
  ensureColumnIndexes();
  const roundText = safeUpper(row[COLS.ROUND] || '');
  return roundText.includes('FINAL');
}

// ============================================
// HIGHLIGHTS GENERATOR FUNCTIONS
// ============================================

/**
 * Generate highlights for today's date
 */
function generateHighlightsToday() {
  const today = new Date();
  const dateStr = Utilities.formatDate(today, Session.getScriptTimeZone(), 'yyyy-MM-dd');
  generateHighlightsWithProgress(dateStr);
}

/**
 * Generate highlights for a specific date (with date picker)
 */
function generateHighlightsForDate() {
  const html = HtmlService.createHtmlOutput(`
    <div style="font-family: Arial, sans-serif; padding: 20px;">
      <h3>Select Date for Highlights</h3>
      <p>Choose the date you want to generate highlights for:</p>
      <input type="date" id="datePicker" style="padding: 8px; font-size: 14px; width: 200px;" />
      <br><br>
      <button onclick="generate()" style="padding: 10px 20px; font-size: 14px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer;">
        Generate Highlights
      </button>
      <div id="status" style="margin-top: 15px; color: #666;"></div>
    </div>
    <script>
      // Set default to today
      document.getElementById('datePicker').valueAsDate = new Date();
      
      function generate() {
        const date = document.getElementById('datePicker').value;
        if (!date) {
          document.getElementById('status').innerHTML = '<span style="color: red;">Please select a date</span>';
          return;
        }
        // Close this dialog and open progress dialog
        google.script.host.close();
        google.script.run.generateHighlightsWithProgress(date);
      }
    </script>
  `)
    .setWidth(350)
    .setHeight(200);
  
  SpreadsheetApp.getUi().showModalDialog(html, 'Select Date');
}

/**
 * Core function to generate highlights
 * Returns a result object instead of showing blocking alerts
 */
function generateHighlights(date) {
  try {
    // Call Firebase Function
    Logger.log(`Calling Firebase Function for date: ${date}`);
    const response = callFirebaseFunction(date);
    
    if (!response.success) {
      throw new Error(response.error || 'Unknown error occurred');
    }
    
    // Upload files to Google Drive
    Logger.log('Uploading files to Google Drive...');
    Logger.log('Response data structure: ' + JSON.stringify(response.data));
    Logger.log('gcsFiles: ' + JSON.stringify(response.data.gcsFiles));
    const uploadResult = uploadToGoogleDrive(response.data);
    Logger.log('Upload result: ' + JSON.stringify(uploadResult));
    
    // Return success result
    return {
      success: true,
      date: date,
      uploadResult: uploadResult
    };
    
  } catch (error) {
    Logger.log(`Error: ${error.message}`);
    Logger.log(error.stack);
    // Return error result instead of showing alert
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Generate highlights with progress dialog (client-side execution)
 */
function generateHighlightsWithProgress(date) {
  const html = HtmlService.createHtmlOutput(`
    <div style="font-family: Arial, sans-serif; padding: 30px; text-align: center;">
      <h3>Generating Highlights...</h3>
      <p>Date: ${date}</p>
      <p style="color: #666; margin-top: 20px;">This may take 1-2 minutes.</p>
      <p style="color: #666;">Please don't close this window.</p>
      <div style="margin-top: 30px;">
        <div style="border: 2px solid #e0e0e0; border-radius: 4px; height: 20px; width: 300px; margin: 0 auto;">
          <div id="progress" style="background: #4285f4; height: 100%; width: 0%; transition: width 0.3s;"></div>
        </div>
      </div>
      <div id="status" style="margin-top: 20px; color: #666;"></div>
    </div>
    <script>
      let progress = 0;
      const interval = setInterval(function() {
        progress += 2;
        if (progress > 90) progress = 90;
        document.getElementById('progress').style.width = progress + '%';
      }, 500);
      
      // Call the server function
      google.script.run
        .withSuccessHandler(function(result) {
          clearInterval(interval);
          document.getElementById('progress').style.width = '100%';
          
          if (result && result.success) {
            // Show success message
            const filesList = result.uploadResult.files.map((f, i) => (i + 1) + '. ' + f.name).join('\\n');
            const message = 'Highlights generated successfully!\\n\\n' +
              'Date: ' + result.date + '\\n' +
              'Total files: ' + result.uploadResult.files.length + '\\n\\n' +
              'Files:\\n' + filesList + '\\n\\n' +
              'Folder: ' + result.uploadResult.folderUrl;
            
            document.getElementById('status').innerHTML = '<p style="color: green;">Complete! Showing results...</p>';
            
            // Close dialog and show success alert
            setTimeout(function() {
              google.script.host.close();
              google.script.run.showHighlightsSuccess(result.date, result.uploadResult);
            }, 500);
          } else {
            // Handle error result
            const errorMsg = result && result.error ? result.error : 'Unknown error occurred';
            document.getElementById('status').innerHTML = '<p style="color: red;">Error: ' + errorMsg + '</p><p style="font-size: 12px; margin-top: 10px;">You can close this dialog manually.</p>';
          }
        })
        .withFailureHandler(function(error) {
          clearInterval(interval);
          document.getElementById('status').innerHTML = '<p style="color: red;">Error: ' + error.message + '</p><p style="font-size: 12px; margin-top: 10px;">You can close this dialog manually.</p>';
          console.error('Error:', error);
        })
        .generateHighlights('${date}');
    </script>
  `)
    .setWidth(400)
    .setHeight(300);
  
  SpreadsheetApp.getUi().showModalDialog(html, 'Generating Highlights');
}

/**
 * Call Firebase Function to generate highlights
 */
function callFirebaseFunction(date) {
  const url = HIGHLIGHTS_CONFIG.FIREBASE_FUNCTION_URL;
  const payload = {
    spreadsheetId: HIGHLIGHTS_CONFIG.SPREADSHEET_ID,
    sheetName: HIGHLIGHTS_CONFIG.SHEET_NAME,
    date: date
  };
  
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true,
    timeout: HIGHLIGHTS_CONFIG.TIMEOUT_MS
  };
  
  Logger.log(`Calling: ${url}`);
  Logger.log(`Payload: ${JSON.stringify(payload)}`);
  
  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  const responseText = response.getContentText();
  
  Logger.log(`Response Code: ${responseCode}`);
  Logger.log(`Response: ${responseText}`);
  
  if (responseCode !== 200) {
    throw new Error(`HTTP ${responseCode}: ${responseText}`);
  }
  
  try {
    const data = JSON.parse(responseText);
    return { success: true, data: data };
  } catch (e) {
    throw new Error(`Failed to parse response: ${e.message}`);
  }
}

/**
 * Upload generated files from GCS to Google Drive
 */
function uploadToGoogleDrive(functionResponse) {
  Logger.log('uploadToGoogleDrive called');
  Logger.log('functionResponse keys: ' + Object.keys(functionResponse).join(', '));
  Logger.log('gcsFiles exists: ' + (functionResponse.gcsFiles ? 'yes' : 'no'));
  if (functionResponse.gcsFiles) {
    Logger.log('gcsFiles keys: ' + Object.keys(functionResponse.gcsFiles).join(', '));
  }
  
  const folder = DriveApp.getFolderById(HIGHLIGHTS_CONFIG.DRIVE_FOLDER_ID);
  Logger.log('Got folder: ' + folder.getName() + ' (ID: ' + folder.getId() + ')');
  
  // Create date-based subfolder
  const dateStr = functionResponse.folderDate || new Date().toISOString().split('T')[0];
  Logger.log('Creating/accessing date folder: ' + dateStr);
  let dateFolder;
  
  try {
    const folders = folder.getFoldersByName(dateStr);
    if (folders.hasNext()) {
      dateFolder = folders.next();
      Logger.log('Found existing date folder: ' + dateFolder.getName());
    } else {
      dateFolder = folder.createFolder(dateStr);
      Logger.log('Created new date folder: ' + dateFolder.getName());
    }
  } catch (e) {
    Logger.log('Error creating date folder: ' + e.message);
    dateFolder = folder; // Fallback to main folder
  }
  
  const uploadedFiles = [];
  
  // Upload HTML file
  if (functionResponse.gcsFiles && functionResponse.gcsFiles.html) {
    try {
      const htmlUrl = functionResponse.gcsFiles.html.publicUrl;
      Logger.log(`Fetching HTML from: ${htmlUrl}`);
      const htmlBlob = UrlFetchApp.fetch(htmlUrl).getBlob();
      
      // Extract filename from filePath or use default
      const filePath = functionResponse.gcsFiles.html.filePath || '';
      const fileName = filePath.split('/').pop() || 'highlights.html';
      
      const htmlFile = dateFolder.createFile(htmlBlob);
      htmlFile.setName(fileName);
      uploadedFiles.push({
        name: htmlFile.getName(),
        url: htmlFile.getUrl(),
        type: 'HTML'
      });
      Logger.log(`Uploaded HTML: ${htmlFile.getName()} to ${dateFolder.getName()}`);
    } catch (e) {
      Logger.log(`Error uploading HTML: ${e.message}`);
      Logger.log(`Stack: ${e.stack}`);
    }
  } else {
    Logger.log('No HTML file in gcsFiles response');
  }
  
  // Upload screenshot images
  if (functionResponse.gcsFiles && functionResponse.gcsFiles.screenshots && functionResponse.gcsFiles.screenshots.length > 0) {
    Logger.log(`Found ${functionResponse.gcsFiles.screenshots.length} screenshot(s) to upload`);
    for (let i = 0; i < functionResponse.gcsFiles.screenshots.length; i++) {
      try {
        const screenshot = functionResponse.gcsFiles.screenshots[i];
        const imageUrl = screenshot.publicUrl;
        Logger.log(`Fetching screenshot ${i + 1} from: ${imageUrl}`);
        const imageBlob = UrlFetchApp.fetch(imageUrl).getBlob();
        
        // Extract filename from filePath or use default
        const filePath = screenshot.filePath || '';
        const fileName = filePath.split('/').pop() || `highlight_${i + 1}.png`;
        
        const imageFile = dateFolder.createFile(imageBlob);
        imageFile.setName(fileName);
        uploadedFiles.push({
          name: imageFile.getName(),
          url: imageFile.getUrl(),
          type: 'Image'
        });
        Logger.log(`Uploaded image: ${imageFile.getName()}`);
      } catch (e) {
        Logger.log(`Error uploading image ${i + 1}: ${e.message}`);
        Logger.log(`Stack: ${e.stack}`);
      }
    }
  } else {
    Logger.log('No screenshots in gcsFiles response');
  }
  
  return {
    folderUrl: dateFolder.getUrl(),
    files: uploadedFiles
  };
}

/**
 * Show success message with links to generated files (non-blocking version)
 */
function showHighlightsSuccess(date, uploadResult) {
  const ui = SpreadsheetApp.getUi();
  
  let message = `Highlights generated successfully!\n\n`;
  message += `Date: ${date}\n`;
  message += `Total highlights: ${uploadResult.files.length} file(s)\n\n`;
  message += `Folder: ${uploadResult.folderUrl}\n\n`;
  message += `Generated files:\n`;
  
  uploadResult.files.forEach((file, index) => {
    message += `${index + 1}. ${file.name} (${file.type})\n`;
  });
  
  message += `\nClick "Open Folder" to view all files.`;
  
  const response = ui.alert(
    'Success!',
    message,
    ui.ButtonSet.OK
  );
  
  // Optionally open the folder
  if (response === ui.Button.OK) {
    // Note: Apps Script can't directly open URLs, but we can show it
    const html = HtmlService.createHtmlOutput(`
      <div style="font-family: Arial, sans-serif; padding: 20px; text-align: center;">
        <h3>Highlights Generated!</h3>
        <p>Click the link below to open the folder:</p>
        <p><a href="${uploadResult.folderUrl}" target="_blank" style="font-size: 16px; color: #4285f4;">Open Highlights Folder</a></p>
        <br>
        <button onclick="google.script.host.close()" style="padding: 10px 20px; font-size: 14px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
      </div>
    `)
      .setWidth(400)
      .setHeight(200);
    
    ui.showModalDialog(html, 'Success');
  }
}

/**
 * Show success message with links to generated files (legacy - kept for compatibility)
 */
function showSuccessMessage(date, uploadResult) {
  showHighlightsSuccess(date, uploadResult);
}

/**
 * Test connection to Firebase Function
 */
function testHighlightsConnection() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    ui.alert('Testing connection...', 'Please wait...', ui.ButtonSet.OK);
    
    const url = HIGHLIGHTS_CONFIG.FIREBASE_FUNCTION_URL;
    const testPayload = {
      spreadsheetId: HIGHLIGHTS_CONFIG.SPREADSHEET_ID,
      sheetName: HIGHLIGHTS_CONFIG.SHEET_NAME,
      date: new Date().toISOString().split('T')[0] // Today's date
    };
    
    const options = {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(testPayload),
      muteHttpExceptions: true,
      timeout: 10000 // 10 seconds for test
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode === 200) {
      ui.alert(
        'Connection Successful',
        `Successfully connected to Firebase Function!\n\nURL: ${url}\n\nYou can now generate highlights.`,
        ui.ButtonSet.OK
      );
    } else {
      const responseText = response.getContentText();
      ui.alert(
        'Connection Issue',
        `HTTP ${responseCode}\n\n${responseText.substring(0, 200)}`,
        ui.ButtonSet.OK
      );
    }
  } catch (error) {
    ui.alert(
      'Connection Failed',
      `Error: ${error.message}\n\nPlease check:\n1. Firebase Function URL is correct\n2. Function is deployed\n3. You have internet connection`,
      ui.ButtonSet.OK
    );
  }
}

// ============================================
// SEA RESULTS SYNC FUNCTIONS
// ============================================

/**
 * Copy competition schedule rows (excluding Technical Meetings) into
 * the SEA Game Schedule & Results sheet (columns B → K only).
 * The sync caps itself at MAX_ROWS rows to avoid touching protected ranges.
 */
const SEA_SYNC_CONFIG = {
  sourceSheetName: 'SEAG25 Competition Schedule',
  headerRow: 8,
  dataStartRow: 9,
  targetSpreadsheetId: '1q62FNYDFJbr3QwJuXM6UJvY0v4rpULtKFuMuoWiiIq8',
  targetSheetName: 'SEA Game Schedule & Results',
  targetHeaderRow: 4,
  targetStartRow: 5,
  targetStartColumn: 2 // column B
};

const SEA_SYNC_MAX_ROWS = 800;

const SEA_SYNC_COLUMNS = [
  'date_and_time',
  'sport',
  'event',
  'athlete_name',
  'opponent_country_flag',
  'medal',
  'opponent',
  'round',
  'venue',
  'result'
];

let SEA_SYNC_HEADER_MAP = null;
let SEA_SYNC_COLS = null;

function syncSeaResults() {
  initializeSeaSyncColumns();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sourceSheet = ss.getSheetByName(SEA_SYNC_CONFIG.sourceSheetName);
  if (!sourceSheet) {
    throw new Error(`Source sheet not found: ${SEA_SYNC_CONFIG.sourceSheetName}`);
  }

  const lastRow = sourceSheet.getLastRow();
  if (lastRow < SEA_SYNC_CONFIG.dataStartRow) {
    SpreadsheetApp.getUi().alert('No schedule rows found.');
    return;
  }

  const sourceValues = sourceSheet
    .getRange(
      SEA_SYNC_CONFIG.dataStartRow,
      1,
      lastRow - SEA_SYNC_CONFIG.dataStartRow + 1,
      sourceSheet.getLastColumn()
    )
    .getValues();

  const eligibleRows = sourceValues
    .filter(row => {
      const event = safeUpperSea(row[SEA_SYNC_COLS.EVENT]);
      const sport = safeUpperSea(row[SEA_SYNC_COLS.SPORT]);
      if (!event || !sport) return false;
      if (event === 'TECHNICAL MEETING') return false;
      return true;
    })
    .map(buildSeaTargetRow)
    .filter(Boolean);

  if (!eligibleRows.length) {
    SpreadsheetApp.getUi().alert('No eligible rows to sync (all filtered).');
    return;
  }

  const rowsToWrite = eligibleRows.slice(0, SEA_SYNC_MAX_ROWS);
  const targetSheet = SpreadsheetApp.openById(SEA_SYNC_CONFIG.targetSpreadsheetId)
    .getSheetByName(SEA_SYNC_CONFIG.targetSheetName);
  if (!targetSheet) {
    throw new Error(`Target sheet not found: ${SEA_SYNC_CONFIG.targetSheetName}`);
  }

  // Always operate on a capped window to avoid protected areas further down.
  const clearRange = targetSheet.getRange(
    SEA_SYNC_CONFIG.targetStartRow,
    SEA_SYNC_CONFIG.targetStartColumn,
    SEA_SYNC_MAX_ROWS,
    SEA_SYNC_COLUMNS.length
  );
  Logger.log(`Clearing block ${clearRange.getA1Notation()}`);
  clearRange.clearContent();

  const writeHeight = rowsToWrite.length;
  const writeRange = targetSheet.getRange(
    SEA_SYNC_CONFIG.targetStartRow,
    SEA_SYNC_CONFIG.targetStartColumn,
    writeHeight,
    SEA_SYNC_COLUMNS.length
  );
  Logger.log(`Writing block ${writeRange.getA1Notation()}`);
  writeRange.setValues(rowsToWrite);

  SpreadsheetApp.getUi().alert(`Synced ${writeHeight} row(s) (capped at ${SEA_SYNC_MAX_ROWS}).`);
}

function buildSeaTargetRow(row) {
  return [
    buildSeaDateTime(row),
    toTitleCaseSea(row[SEA_SYNC_COLS.SPORT_TEAMSG] || row[SEA_SYNC_COLS.SPORT]),
    row[SEA_SYNC_COLS.EVENT] || '',
    toTitleCaseSea(row[SEA_SYNC_COLS.ATHLETE_NAME]),
    formatSeaOpponentCountry(row),
    formatSeaMedal(row),
    toTitleCaseSea(row[SEA_SYNC_COLS.COMPETITOR_NAME]),
    row[SEA_SYNC_COLS.ROUND] || '',
    row[SEA_SYNC_COLS.VENUE] || '',
    formatSeaResult(row)
  ];
}

function buildSeaDateTime(row) {
  const datePart = formatSeaDate(row[SEA_SYNC_COLS.DATE_THA]);
  const timePart = formatSeaTime(row[SEA_SYNC_COLS.TIME_START_THA]);
  return [datePart, timePart].filter(Boolean).join(' ');
}

function formatSeaMedal(row) {
  const medalIdx = SEA_SYNC_COLS.MEDAL_TEXT ?? SEA_SYNC_COLS.MEDAL_RESULT;
  const raw = medalIdx !== undefined ? (row[medalIdx] || '').toString().trim() : '';
  if (!raw) return '';
  const lower = raw.toLowerCase();
  if (lower.includes('gold')) return 'Gold';
  if (lower.includes('silver')) return 'Silver';
  if (lower.includes('bronze')) return 'Bronze';
  return raw;
}

function formatSeaResult(row) {
  let resultText = row[SEA_SYNC_COLS.WEB_RESULTS] || row[SEA_SYNC_COLS.WHATSAPP_AUTO] || '';
  const medal = formatSeaMedal(row).toLowerCase();
  if (medal.includes('gold')) {
    resultText = `🥇 ${resultText}`.trim();
  } else if (medal.includes('silver')) {
    resultText = `🥈 ${resultText}`.trim();
  } else if (medal.includes('bronze')) {
    resultText = `🥉 ${resultText}`.trim();
  }
  return resultText;
}

function formatSeaOpponentCountry(row) {
  const code = safeUpperSea(row[SEA_SYNC_COLS.COMPETITOR_COUNTRY]);
  if (!code) return '';
  return SEA_COUNTRY_MAP[code] || code;
}

function formatSeaDate(value) {
  if (!value) return '';
  if (value instanceof Date) {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const day = value.getDate().toString().padStart(2, '0');
    return `${day} ${months[value.getMonth()]}`;
  }
  return value.toString();
}

function formatSeaTime(value) {
  if (!value) return '';
  if (value instanceof Date) {
    return Utilities.formatDate(value, Session.getScriptTimeZone(), 'HH:mm');
  }
  const text = value.toString();
  if (/^\d{2}:\d{2}/.test(text)) {
    return text.substring(0, 5);
  }
  return text;
}

function addSeaOrdinal(value) {
  const num = parseInt(value, 10);
  if (isNaN(num)) return '';
  if (num % 100 >= 11 && num % 100 <= 13) return `${num}th`;
  switch (num % 10) {
    case 1: return `${num}st`;
    case 2: return `${num}nd`;
    case 3: return `${num}rd`;
    default: return `${num}th`;
  }
}

function initializeSeaSyncColumns() {
  if (SEA_SYNC_COLS) return;

  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SEA_SYNC_CONFIG.sourceSheetName);
  if (!sheet) {
    throw new Error(`Source sheet "${SEA_SYNC_CONFIG.sourceSheetName}" not found.`);
  }

  const headerRow = sheet
    .getRange(SEA_SYNC_CONFIG.headerRow, 1, 1, sheet.getLastColumn())
    .getValues()[0];

  SEA_SYNC_HEADER_MAP = {};
  headerRow.forEach((value, idx) => {
    const normalized = safeUpperSea(value);
    if (normalized) {
      SEA_SYNC_HEADER_MAP[normalized] = idx;
    }
  });

  const lookup = (label, fallback) => {
    const normalized = safeUpperSea(label);
    if (normalized in SEA_SYNC_HEADER_MAP) {
      return SEA_SYNC_HEADER_MAP[normalized];
    }
    if (fallback) {
      const fallbackNorm = safeUpperSea(fallback);
      if (fallbackNorm in SEA_SYNC_HEADER_MAP) {
        return SEA_SYNC_HEADER_MAP[fallbackNorm];
      }
    }
    throw new Error(`Missing expected column "${label}" in source sheet.`);
  };

  const optional = (label, fallback) => {
    const normalized = safeUpperSea(label);
    if (normalized in SEA_SYNC_HEADER_MAP) {
      return SEA_SYNC_HEADER_MAP[normalized];
    }
    if (fallback) {
      const fallbackNorm = safeUpperSea(fallback);
      if (fallbackNorm in SEA_SYNC_HEADER_MAP) {
        return SEA_SYNC_HEADER_MAP[fallbackNorm];
      }
    }
    return null;
  };

  SEA_SYNC_COLS = {
    DATE_THA: lookup('DATE'),
    TIME_START_THA: lookup('TIME START (THA) 24HR CLOCK'),
    SPORT_TEAMSG: optional('SPORT (TEAMSG WEBSITE)'),
    SPORT: lookup('SPORT'),
    EVENT: lookup('EVENT'),
    ATHLETE_NAME: lookup('NAME OF ATHLETE (SGP)'),
    COMPETITOR_NAME: lookup('NAME OF ATHLETE (COMPETITOR)'),
    COMPETITOR_COUNTRY: lookup('COUNTRY NAME (COMPETITOR)'),
    ROUND: lookup('STAGE / ROUND OF COMPETITION'),
    VENUE: lookup('COMPETITION VENUE'),
    WHATSAPP_AUTO: lookup('WHATSAPP MESSAGE (AUTO GENERATED)'),
    WEB_RESULTS: lookup('WEB RESULTS (AUTO GENERATED)'),
    ROUND_POSITION: lookup('POSITION IN ENTIRE ROUND'),
    ROUND_COMPETITORS: lookup('NO OF COMPETITORS IN ENTIRE ROUND'),
    H2H_RESULT: lookup('H2H WIN/DRAW/LOSE'),
    MEDAL_RESULT: lookup('MEDALS'),
    MEDAL_TEXT: optional('MEDAL', 'MEDALS')
  };
}

function safeUpperSea(value) {
  return value ? value.toString().trim().toUpperCase() : '';
}

const SEA_COUNTRY_MAP = {
  BRU: 'Brunei',
  CAM: 'Cambodia',
  INA: 'Indonesia',
  LAO: 'Laos',
  MAS: 'Malaysia',
  MYA: 'Myanmar',
  PHI: 'Philippines',
  SGP: 'Singapore',
  THA: 'Thailand',
  TLS: 'Timor-Leste',
  VIE: 'Vietnam'
};

function toTitleCaseSea(value) {
  if (!value) return '';
  const text = value.toString().trim().toLowerCase();
  if (!text) return '';
  return text.replace(/\b\w/g, char => char.toUpperCase());
}


